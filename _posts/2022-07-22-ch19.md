---
title: Chapter 19 Networks and Distributed Systems
author: jaekim
date: 2022-07-22
layout : post
---
| 작성자  |   작성일   |
| :-----: | :--------: |
| jaekim | 2022.07.22 |

# Chapter 19 Networks and Distributed Systems

# ❏ 네트워크 및 분산 시스템

# ❏ 분산 시스템?

- 메모리를 공유하지 않는 프로세서 모음
- 각 노드는 자체 로컬 메모리를 가짐
- 통신 네트워크에 의행 상호 연결된 노드들의 집합

# ❏ 19.1 분산 시스템의 장점

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled.png)

<aside>
💡 1.  자원 공유
2. 계산 속도 향상
3. 신뢰성

</aside>

## ✏️ 자원 공유

- 여러 다른 사이트가 서로 연결되면, 한 사이트의 사용자가 다른 사이트의 자원을 사용 가능
    - 원격 특수 하드웨어 장치 사용 및 다른 작업을 할 수 있는 기법을 제공
        - 원격 파일 공유, 분산 데이터베이스에서 정보 처리, 원격 사이트에서 파일 인쇄 등

## ✏️ 계산 속도 향상

- Load Balancing ( 부하 균등화 )
- 계산을 여러 사이트에 분산하여 동시 실행이 가능하기 때문에 계산 속도가 향상
    
    ex) 빅데이터와 같은 대규모 처리
    

## ✏️ 신뢰성

- 하나의 사이트에 장애가 발생해도, 나머지 사이트가 계속 작동해서 시스템의 신뢰성이 향상
    
    ❗️웹 서버 또는 파일 시스템과 같은 중요한 시스템 기능을 담당하면 시스템 작동이 중단될 수 있다.
    

# ❏ 19.2 네트워크 구조

- 통신 네트워크의 속도와 신뢰성은 매우 다양함

<aside>
💡 1.  근거리 통신망 (LAN)
2. 원거리 통신망 (WAN)

</aside>

## ✏️ 근거리 통신망 (LAN_ Local Area Network)

- 일반적으로 이더넷과 WiFi 가 LAN을 구성하는데 사용됨
- 시스템의 모든 사이트가 서로 가깝기 때문에 WAN의 링크보다 속도가 빠르고 오류률이 낮음
- 여러 다른 컴퓨터, 주변 장치 및 네트워크에 대한 접근을 위해 하나 이상의 라우터로 구성
- Wireless Access point
    - 무선 액세스 포인트(wireless access point, WAP)는 컴퓨터 네트워크에서 WiFi를 이용한 관련 표준을 이용하여 무선 장치들을 유선 장치에 연결할 수 있게 하는 장치를 가리킴
        
        ![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%201.png)
        
    
    [무선 액세스 포인트 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%AC%B4%EC%84%A0_%EC%95%A1%EC%84%B8%EC%8A%A4_%ED%8F%AC%EC%9D%B8%ED%8A%B8)
    

## ✏️ 광역 통신망 (WAN_ Wide Area Network))

- 사이트 간 효율적인 통신을 제공하여 광범위한 사용자가 편리하고 경제적으로 하드웨어와 소프트웨어를 공유할 수 있게 하기 위해 등장
- 최초의 WAN은 ARPANET, 후에 인터넷 (World Wide Web) 으로 성장

[인터넷 이야기, 인터넷의 어원 international network, 인터넷의 효시 ARPANET(알파넷)](https://gominless.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%84%B7-%EC%9D%B4%EC%95%BC%EA%B8%B0-%EC%9D%B8%ED%84%B0%EB%84%B7%EC%9D%98-%EC%96%B4%EC%9B%90-international-network-%EC%9D%B8%ED%84%B0%EB%84%B7%EC%9D%98-%ED%9A%A8%EC%8B%9C-ARPANET%EC%95%8C%ED%8C%8C%EB%84%B7)

- 넓은 지역에 물리적으로 분포
    - 전화선, 광케이블, 마이크로파 링크
- 트래픽을 다른 라우터 및 네트워크에 보내며, 정보는 전송하는 라우터가 제어
    - 호스트는 보통 LAN에 있고, 지역 네트워크를 통해 인터넷에 연결된다. 이때 라우터와 연결되어 전 세계 네트워크를 형성
    - 일반 가정은 ISP 를 통해 라우터 또는 케이블 등을 설치하여 인터넷에 연결
        - ISP ⇒ 인터넷 서비스 제공업체
            
            (Internet Service Provider)
            

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%202.png)

- 일반적으로 LAN 보다 느리다.

# ❏ 19.3 통신 구조

<aside>
💡 1. 이름 지정 및 이름 찾기
2. 원거리 통신망 (WAN)
3. 통신 프로토콜
4. OSI 모델
5. TCP / IP 모델
6. 전송 프로토콜 UDP 및 TCP

</aside>

## ✏️ 이름 지정 및 이름 찾기

- 사이트 A 와 사이트 B의 프로세스가 정보 교환을 하려면 서로를 지정해야함

> 컴퓨터 시스템 내부에서의 정보 교환
> 
- 컴퓨터 시스템 내에서 정보 교환은 **프로세스 식별자**를 주소로 사용함
    - 메모리를 공유하기 때문에 식별자 하나로 통신이 가능

> 네트워크로 연결된 시스템에서의 정보 교환
> 
- 네트워크로 연결된 시스템은 메모리를 공유하지 않기 때문에 다른 호스트의 프로세스를 알 수 없음
- **<호스트 이름, 식별자> 쌍으로 식별**
    - 호스트 이름
        - 네트워크 내에서 고유한 이름
        - 쉽게 인식하기 위해 영숫자 식별자를 이용
            - 128.148.31.100 이라는 숫자형 호스트 주소 대신
                
                → program 이라는 영문 이름 이용
                
    - 식별자
        - 해당 호스트 내의 프로세스 식별자 또는 고유 번호

> 호스트 id 변환 기법 ( 2가지 )
> 
- 사람은 글자를 선호하지만, 컴퓨터는 숫자를 선호한다. (속도, 단순성)
- 호스트 이름 → 호스트 id 로 변환하는 기법이 필요
    - 모든 호스트는 네트워크를 통해 연결할 수 있는 다른 호스트의 이름과 숫자 주소에 대한 데이터 파일을 가짐
        
        ❗️ 단, 호스트를 추가하거나 제거하려면 모든 호스트에서 파일을 업데이트 해야함
        
    - 네트워크 상에 시스템 간에 정보를 배포, 네트워크는 프로토콜을 사용하여 정보를 배포 및 검색
        
        ☝🏻 실시간 바인딩과 같고, 인터넷은 **DNS(domain - name system)** 을 사용하여 호스트 이름 확인
        

> DNS
> 
- 호스트의 이름 지정 구조뿐만 아니라 이름 - 주소 변환을 지정
- 인터넷 호스트는 IP 주소로 표기됨.
    - IP 주소의 필드들은 마침표와 함께 구체적인 것 → 일반적인 것으로 구분
        
        ex) eric.cs.yale.edu ⇒ edu 의 Yale University 컴퓨터 과학부의 호스트 eric 을 나타냄
        
    - 각 구성 요소는 네임 서버 (name server) 를 가짐
        1. 커널은 edu 도메인 담당 네임 서버에 yale.edu를 담당하는 네임 서버의 주소를 요청함
        2. edu 네임 서버는 yale.edu의 네임 서버가 있는 호스트 주소를 반환
        3. 1, 2를 반복해서 cs.yale.edu의 네임 서버가 있는 호스트 주소 반환
        4. eric.cs.yale.edu에 대한 주소를 요청하면 인터넷 주소 호스트 id를 반환(ex. 128.148.31.100)

## ✏️ 통신 프로토콜

- 통신 네트워크를 설계할 때 발생하는 다양한 문제를 여러 층으로 분할하여 단순화할 수 있음
- 층마다 고유 프로토콜이 있고, 특정 프로토콜을 사용하여 다른 층과 통신함
- 한 시스템의 각 층은 다른 시스템의 해당 층과 통신함
- 프로토콜은 하드웨어와 소프트웨어로 구현될 수 있음
    - 하드웨어로 구현된 3개의 최하위층을 사용하는 두 컴퓨터 간의 논리적 통신
        
        ![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%203.png)
        

### ☝🏻 OSI 모델

- 국제표준기준(ISO)는 다양한 네트워킹 층을 설명하기 위해 OSI 모델을 만듬
    - 계층 별 역할
        
        > 물리층 (1층)
        > 
        - 비트 전송을 책임짐
        - 네트워킹 장치의 하드웨어에서 구현
        
        > 데이터 링크층 (2층)
        > 
        - 물리층에서 발생하는 오류 감지 및 복구
        - 프레임 또는 고정 길이의 패킷 처리를 담당
        - 물리 주소 간에 프레임을 보냄
        
        > 네트워크층 (3층)
        > 
        - 메시지를 패킷으로 나눔
        - 패킷 라우팅 (패킷의 주소 처리, 패킷 주소 해독 및 부하 수준 변경을 위한 라우팅 정보 유지) 담당
        - 논리 주소 사이의 연결을 제공
        - 라우터 작동
        
        > 전송층 (4층)
        > 
        - 노드 간 메시지 전송
        - 패킷 순서 유지 및 혼잡을 피하기 위한 흐름 제어
        
        > 세션층 (5층)
        > 
        - 세션 또는 프로세스 간 통신 프로토콜 구현
        
        > 프리젠테이션층 (6층)
        > 
        - 문자 변환 등 네트워크의 여러 사이트 간의 형식 차이를 해결
        
        > 응용 프로그램층 (7층)
        > 
        - 사용자와 직접 상호 작용
        

> OSI 프로토콜 스택을 통해 보는 데이터의 물리적 흐름
> 

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%204.png)

- 송신 프로세스에서 데이터를 전송
- 응용 프로그램 층에서 시작하여 하위층을 차례로 통과
- 데이터 통신 네트워크 층에 도달하여 패킷 단위로 목적지 시스템에 전송
- 목적지 시스템의 데이터 링크 층은 패킷을 수신, 메시지는 프로토콜 스택을 통해 위로 이동
- 응용 프로그램 층에 도착 & 수신 프로세스에서 사용 가능

### ☝🏻 TCP / IP 모델

- OSI 계층의 여러 층의 기능을 합쳤기 때문에 적은 층을 가짐
- 전송 층
    - UDP 와 TCP 를 식별
- 인터넷 프로토콜 (IP)
    - 데이터그램 또는 패킷을 라우팅하는 일을 담당
- 모든 호스트에는 이름과 연결된 IP 주소가 있다. 이름과 IP 주소는 유일하다.
- 호스트 id 는 네트워크 번호와 호스트 번호로 나뉜다.

[[네트워크] IP Address](https://nalt-it.tistory.com/56)

> 통신 순서
> 
- 송신 시스템은 자신의 라우팅 테이블을 점검하여 프레임을 송신할 라우터를 찾음
    
    (시스템 관리자 또는 BGP_Border Gateway Protocal 이 함)
    
- 라우터는 호스트 id 의 네트워크 부분을 사용하여 목적지 네트워크로 패킷을 전송
- 목적지 시스템, 패킷 수신
- 패킷을 통해 전체 메시지를 수신하면 TCP / UDP (전송) 층으로 전달

---

- 네트워크 내에서 패킷은 송신자에서 수신자로 어떻게 이동하는가?
    - 모든 이더넷 장치에는 주소 지정을 위해 할당된 MAC 주소가 있음. LAN은 이 번호로만 통신
        - medium access control
    - 다른 시스템과 통신할 경우, 목적지 시스템의 IP 주소를 포함하는 ARP 패킷 생성
        - Address Resolution Protocal
        - ARP 패킷은 해당 이더넷 네트워크의 있는 시스템 전체에 브로드캐스트 함

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%205.png)

### ☝🏻 전송 프로토콜 UDP 및 TCP

- IP 주소를 가진 호스트가 패킷을 받으면 정확한 대기 프로세스에 전달해야 한다.
- TCP 와 UDP 는 포트 번호를 사용하여 수신(및 송신) 프로세스를 식별한다.

> User datagram protocol (UDP)
> 
- 전송 층은 신뢰할 수 없는 무연결
- IP에 포트 번호를 추가한 정도의 기본적인 확장
- 소스 포트 번호, 목적지 포트 번호, 길이, 체크섬

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%206.png)

> Transmission control protocol (TCP)
> 
- 안정적인 연결 지향
- 포트 번호 명시뿐만 아니라 호스트의 송신 및 수신 프로세스 순서가 지켜짐. 다음 기법을 사용함.
    - 수신자는 수신되었음을 송신자에게 알림. 이때 접수 통지 패킷 또는 ACK 를 보냄. 타이머가 만료되기 전에 ACK가 수신되지 않으면 송신자는 해당 패킷을 다시 보냄
    - 모든 패킷의 TCP 헤더에 시퀀스 번호를 도입
        
        요청 프로세스에 데이터 보내기 전에 패킷을 배치
        
        ☝🏻 바이트 스트림에서 누락된 패킷 인지. ( 1바이트를 입출력할 수 있는 스트림 )
        
    - 제어 패킷을 사용하여 송신자와 수신자 모두 상태를 설정하고 제거
    
    ❗️모든 패킷에 대해서 ACK가 필요하지는 않다. 대신 누적 ACK를 전송할 수 있음
    
    ⭐️ 서버는 네트워크 처리량을 활용하기 위해 ACK 를 기다리기 전에 많은 데이터 패킷을 순차적으로 보낼 수 있음
    
- 흐름제어
    - 발신자가 수신자의 용량을 초과하는 것을 방지
        - 수신자의 연결 속도가 느린 경우 or 하드웨어 구성요소가 느린 경우
    - ACK 패킷으로 발신자의 속도 저하 또는 속도 증가 상태를 경고할 수 잇음.

- 혼잡제어
    - 송신자와 수신자 사이의 네트워크의 상태를 어림 계산함
    - 라우터가 많은 패킷을 받으면, 패킷을 생략하려고 함.
        
        패킷을 생략하면 ACK 시간 초과가 발생하여 더 많은 패킷이 네트워크를 포화 상태로 만듬.
        
    - 이러한 상태를 방지하기 위해 송신자는 ACK를 받지 않은 패킷 수를 확인하여 연결에서 생략된 패킷을 모니터링 함.
    - 패킷이 너무 많으면 송신자는 패킷을 보내는 속도를 늦춤.

- TCP 연결이 동시에 발생하는 다른 연결에 대해 공정하게 되도록 하는데 도움이 됨
- TCP 는 UDP 보다 느림

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%207.png)

# ❏ 19.4 네트워크 및 분산 운영체제

<aside>
💡 1. 네트워크 운영체제
2. 분산 운영체제

</aside>

- 네트워크 운영체제는 분산 운영체제보다 구현하기 더 간단함
- 분산 운영체제가 더 많은 기능을 제공함

## ✏️ 네트워크 운영체제

- 원격 로그인 & 원격 자원 공유 환경 제공
- Android & ios 같은 임베디드 운영체제

### ☝🏻원격 로그인

- 네트워크 운영체제의 중요한 기능은 사용자가 원격 로그인을 가능하게 하는 것
    - ssh 기능

> 원격 로그인 단계
> 
- A 시스템이 B 시스템에 접속하려고 할 때, ssh 를 이용함
    
    ssh [A 시스템 주소] 를 입력하면 컴퓨터 간에 암포화된 소켓 통해 서로를 연결함
    
    사용자가 입력한 모든 문자가 A로 전송되고, 해당 프로세스의 모든 출력이 사용자에게 다시 전송됨
    
- 원격 시스템의 프로세스는 사용자에게 로그인과 비밀번호를 물음
- 올바른 정보가 수신되면 프로세스는 사용자의 프록시 역할을 하며, 사용자는 원격 시스템에 접속할 수 있게 됨

### ☝🏻원격 파일 전송

- 각 컴퓨터가 자체 로컬 파일 시스템을 유지 & 관리함

> 원격 파일 전송 단계
> 
- A 컴퓨터가 B 컴퓨터 파일에  접근하려고 하면, B 컴퓨터에서 A 컴퓨터로 파일을 복사해야 함
- 컴퓨터 통신은 단방향적이고 개별적이기 때문에, A, B 컴퓨터에서 파일을 전송하고자 하는 다른 사용자는 일련의 명령을 내려야 함
    - 파일 전송을 위해 FTP와 SFTP를 제공
        - FTP : file transfer protocol
        - SFTP : Private Secure File Transfer Protocol
        - A에서 B의 파일을 복사하려고 하면 sftp 프로그램을 호출해야함.
        - 프로그램은 A 에게 로그인 & 비밀번호를 요구하고, 올바른 정보가 수신되면 파일을 복사할 수 있게 됨

### ☝🏻클라우드 저장장치

- 클라우드 기반 저장장치 응용 프로그램은 FTP와 같이 파일을 전송할 수 있음
- GUI 를 통해 웹 링크 or 다른 공유 기법으로 클라우드 서버를 통해 파일을 공유할 수 있음
- Dropbox, Google Drive

### ☝🏻특징

- SSH, FTP, 클라우드는 사용자가 패러다임을 변경해야 함
    - FTP 사용자는 일반 운영체제 명령과 완전히 다른 명령 집합을 알아햐 함
    - SSH 사용자는 원격 시스템의 명령어를 알아야 함
        - Windows → Unix에 원격 접속하면, SSH 세션 동안 UNIX 명령으로 전환해야 함
        
        ❗️네트워킹에서 세션은 인증을 위한 로그인부터 로그오프로 끝나는 완전한 통신 라운드
        
    - 클라우드 기반 저장장치는 클라우드 서비스(웹 브라우저), 네이티브 응용 프로그램에 로그인 필요

- 명령 집합을 사용하는 것은 매우 불편함. 이를 해결하기 위해 분산 운영체제가 등장

## ✏️ 분산 운영체제

- 한 시스템에서 다른 시스템으로 데이터 및 프로세스 마이그레이션은 분산 운영체제의 제어하에 있음
- 시스템의 목표에 따라 데이터 마이그레이션, 계산 마이그레이션, 프로세스 마이그레이션 또는 이들의 조합을 구현할 수 있음

### ☝🏻 데이터 마이그레이션

- 시스템 A 사용자가 시스템 B에 있는 데이터에 엑세스 하려고 할 때, 2가지 방법이 있음
    1. B 의 전체 파일을 A로 전송
        1. 이 시점부터 파일에 대한 접근은 로컬임
    2. 필요한 일부만 A로 전송
- 두 시스템이 호환되지 않은 경우 다양한 데이터 변환이 필요

### ☝🏻 계산 마이그레이션

- 데이터 대신 계산을 시스템 전체에 전송하는 경우

### ☝🏻 프로세스 마이그레이션

- 계산 마이그레이션의 논리적 확장
- 프로세스가 실행될 때 프로세스가 시작된 사이트에서 항상 실행되는 것은 아님. 다른 시스템에서 실행될 수 있음
    
    ❓왜 다른 시스템에서 실행되기도 할까
    
    1. 부하 균등화 → 작업의 부하를 분산
    2. 계산 속도 향상 → 단일 프로세스를 여러 서브 프로세스로 나누면 프로세스 처리시간 감소
    3. 하드웨어 선호도 → 프로세스는 CPU 보다 GPU 같은 특수 프로세서에서 실행하기 더 적합할 수 있음
    4. 소프트웨어 선호도 → 프로세스는 특정 시스템에서만 사용 가능한 소프트웨어를 필요로 할 수 있음.
    5. 데이터 접근 → 계산에 사용하는 데이터가 많으면 로컬보다 원격으로 프로세스를 실행하는 것이 효율적일 수 있음
- 네트워크에서 프로세스를 이동시키기 위해 2가지 보완적인 기술을 사용
    1. 시스템은 프로세스가 클라이언트에서 마이그레이션되었다는 사실을 숨기려고 시도함
        
        원격으로 프로그램을 실행하는데 필요한 사용자 입력이 필요하지 않기 때문에 부하 균등화 및 계산 속도를 향상
        
    2. 프로세스를 어떻게 마이그레이션 해야하는지 사용자가 명시적으로 지정할 수 있게 허용하는 것임
        
        일반적으로 HW / SW 선호도를 충족시키기 위해 프로세스를 이동할 때 사용
        

# ❏ 19.5 분산 시스템의 설계 문제

<aside>
💡 1. 견고성
2. 투명성
3. 확장성

</aside>

## ✏️ 견고성

> 결함 허용성
> 
- 시스템은 일정 수준의 장애를 허용하고 계속 정상적으로 작동할 수 있음
- 구현하기 어렵고 비용이 많이 들 수 있음

### ↘︎ 결함 허용의 과정

### ☝🏻 1. 장애 감지

- 공유 메모리가 없는 환경에서는 장애 발생 사실을 감지할 수 있지만,
    
    링크&사이트&호스트 장애 및 메시지 손실 중 어떤 문제인지 구분할 수 없음
    
- 장애 감지를 위해서 심장박동 절차를 사용함
    - A 와 B 시스템 사이에 링크가 있다면, 서로 메시지를 보냄
        
        정해진 시간 내에 메시지를 받지 못하면 한 시스템이 고장났거나, 링크에 장애가 있거나, 메시지가 유실됬다는 것을 알 수 있음
        
        ❗️하지만 어떤 이벤트가 발생했는지 결정할 수 없음
        

### ☝🏻 2. 재구성

- 장애가 발생했음을 발견했다면, 시스템을 재구성하고 정상 작동 모드로 계속할 수 있게 절차를 시작해야 함
    - 두 시스템이 링크에 실패한 경우
        - 다양한 라우팅 테이블이 이에 맞게 업데이트 되야함 (브로드캐스트)
    - 시스템에 장애가 발생한 경우
        - 장애가 발생한 시스템의 서비스를 사용하지 못하도록 다른 시스템에 통보해야 함

### ☝🏻 3. 장애 복구

- 장애가 발생한 링크 또는 시스템이 수리되면, 단계적으로 통합되어야함
    - A와 B 사이에 링크 장애가 발생한 경우
        - 링크가 수리될 때 A와 B에 모두 통보
    - B 시스템에 장애가 발생한 경우
        - 복구될 때 다른 모든 사이트에 다시 작동중임을 알려야함
        - B 시스템은 다른 사이트로부터 정보를 받아 로컬 테이블에 업데이트해야 함

## ✏️ 투명성

- 분산 시스템의 여러 프로세서와 저장장치를 사용자에게 투명하게 만들어야 함
    - 이상적으로 사용자에게 중앙 집권형 시스템처럼 보여야 함
        
        → 사용자는 원격 자원에 접근할 때, 로컬 자원에 접근할 때처럼 접근해야 함
        
        → 분산 시스템은 적절하게 자원을 제공하며 사용자와 상호작용할 준비가 되어있어야 함
        
- 이동성
    - 사용자가 특정 기기를 사용하는 것보다 어떤 기기로든 로그인 할 수 있도록 하는 것이 편리함
    - 사용자가 로그인하는 모든 곳에 사용자 환경을 적용하여 이동성을 용이하게 함
        - 인증 시스템 프로토콜이 있음 (ex. LDAP)
            
            [LDAP 인증 제공자 유형](https://help.blackboard.com/ko-kr/Learn/Administrator/SaaS/Authentication/Implement_Authentication/LDAP_Authentication_Provider_Type)
            

## ✏️ 확장성

- 증가하는 서비스 부하에 적응할 수 있는 시스템의 능력
- 확장 가능한 시스템은 확장 불가능한 시스템보다 증가한 부하에 더 단계적으로 반응함
    - 성능이 더욱 적정 수준으로 저하
    - 자원이 더 늦게 포화 상태에 도달
- 확장 가능한 시스템은 시스템 확장 시 비용이 많이 들지 않으며 확장해야함
    - 새 기계를 추가하거나 두 개의 네트워크를 상호 연결하여 네트워크를 확장하는 것이 일반적이기 때문에, 단계적으로 확장할 수 있는 능력이 중요함
- 결함 허용과 관련하여, 부하가 높은 구성요소는 마비되어 결함이 있는 구성요소처럼 작동할 수 있음
    
    이때, **여유 자원의 보유**는 부하를 단계적으로 처리하기 위해 필수적임
    
    그렇기 때문에 분산 시스템의 여러 자원은 결함 허용성 및 확장성에 이점이 있음
    
    ❗️부적절한 설계는 이점을 모호하게 할 수 있음. 제어 및 데이터가 분산되어 있는 것을 증명할 설계가 필요
    
- 효율적인 저장장치 기법과 관련이 있음.
    - 클라우드 저장장치 공급자는 압축 또는 중복 제거를 사용하여 저장장치 사용량을 줄임
        - 압축 → zip
        - 중복 제거 → 중복 데이터를 제거하여 저장장치 요구 사항을 낮춤
            
            (여러 사용자가 소유한 데이터에도 하나의 데이터 인스턴스만 저장)
            
    - 저장 공간을 절약하고 복잡성을 가중하지 않으며 네트워크 통신 비용을 줄임

# ❏ 19.6 분산 파일 시스템

<aside>
💡 1. DFS
2. 클라이언트-서버
3. 클러스터

</aside>

- 분산 파일 시스템 또는 DFS는 대중적인 분산 시스템 중 하나

## ✏️ DFS

- DFS 는 클라이언트, 서버, 및 저장장치가 분산 시스템의 기기에 분산된 파일 시스템임
    - 서비스 활동은 네트워크를 통해 수행
- DFS 에서의 서비스, 서버, 클라이언트?
    - 서비스 : 하나 이상의 시스템에서 실행되고 클라이언트에 특정 유형의 기능을 제공하는 소프트웨어 객체
    - 서버 : 단일 시스템에서 실행되는 서비스 소프트웨어
    - 클라이언트 : 클라이언트 인터페이스를 통해 서비스를 호출하는 프로세스
        - 파일 시스템이 클라이언트에게 파일 서비스를 제공함
            - 파일 서비스를 위한 클라이언트 인터페이스에는 파일 생성, 삭제, 읽기, 쓰기와 같은 연산 집합이 있음
- DFS의 독특한 특징은 클라이언트와 서버의 다양성과 자율성
    - DFS의 클라이언트 인터페이스는 투명성이 있어야하며 이동성을 용이하게 해야 함
- DFS 성능 척도
    - 서비스 요청을 충족시키는데 필요한 시간
        
        (기존 시스템에서는 저장장치 엑세스 시간 + 소량의 CPU 처리 시간)
        
        ☝🏻 DFS는 원격 액세스에 대한 오버헤드를 포함 (요청과 응답을 받는 시간, 통신 프로토콜 실행 시간 등)
        

- 2가지 DFS 아키텍처 모델에는 목표에 따라 <클라이언트 - 서버 모델>과 <클러스터 기반 모델>이 있음.
    - 전자는 파일이 개별 클라이언트 시스템에 로컬로 저장된 것처럼 하나 이상의 클라이언트 간에 투명한 파일 공유
    - 후자는 많은 응용 프로그램을 병렬로 실행해야 하는 경우

## ✏️ 클라이언트 서버 DFS 모델

- 서버는 파일과 메타데이터를 모두 연결된 저장장치에 저장
- 클라이언트는 네트워크를 통해 서버에 연결되며, 프로토콜(ex. NFS)을 통해 서버에 접속하고 DFS 파일에 대한 엑세스를 요청할 수 있음
- 서버는 인증 수행, 요청된 파일에 대한 권한 확인 후 클라이언트에게 전송할 책임 있음
- 클라이언트가 파일을 변경할 때, 변경 사항을 서버에 전달해야 함

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%208.png)

- NFS(Network File System) 프로토콜의 초점은 서버 장애 시 간단하고 빠른 크래시 복구
    - 이를 위해 서버는 상태가 없는 방식으로 설계 됨
        
        즉, 클라이언트가 어떤 파일에 엑세스하는 중인지, 열린 fd 및 파일 포인터 같은 것을 추적하지 않음
        
    - 클라이언트가 파일 연산 시, 서버가 크래시 되면 해당 연산이 멱등함
        - 멱등 : 같은 연산을 두번하지만, 동일한 결과를 반환하는 연산

- Andrew 파일 시스템(OpenAFS)는 확장성에 중점을 두고 만들어짐
    - 즉, 서버가 많은 클라이언트를 지원할 수 있는 프로토콜을 목표로 함
    - 서버로의 요청 및 트래픽을 최소화하는 것을 의미
    - 클라이언트가 파일을 요청하면, 파일 내용을 서버에서 다운로드하여 클라이언트 로컬에 저장
        
        파일이 닫히면 업데이트 내용을 서버로 전송, 파일을 열면 새 버전의 파일이 클라이언트로 전송
        
        ❗️NFS는 Andrew 파일 시스템과 다르게 파일을 사용할 때마다 서버에 읽기 및 쓰기 요청을 보냄
        

- NFS 와 OpenAFS는 모두 로컬 파일 시스템에 추가하여 사용함
    - 클라이언트가 선택한 서버의 로컬 파일 시스템으로 파티션을 포맷하고 DFS를 통해 공유 디렉터리를 보냄
    - 클라이언트는 보내진 공유 디렉터리를 자신의 파일 시스템 트리에 붙임
    - DFS는 로컬 파일 시스템에 대한 책임에서 벗어나서 분산 작업에 집중함

- 서버가 크래시되면 단일 장애점을 겪을 수 있음
    - 클러스터링 방법을 사용하여 이 문제를 해결할 수 있음
        
        클러스터링은 장애를 감지하고, 작동 중인 구성요소로 시스템을 대체 작동하여 서버 연산을 계속할 수 있게 함
        

## ✏️ 클러스터 기반 모델

### ☝🏻 등장 배경

- I / O 부하 및 처리량이 증가함에 따라 DFS 결함 허용성 및 확장성을 갖추어야할 필요성도 증가
- 큰 병목현상은 허용되지 않고, 시스템 구성요소 장애는 예상되어야 함

### ☝🏻 특징

- Google 파일 시스템(GFS)과 Hadoop 분산 파일 시스템(HDFS)에서 제시한 모델
- 클라이언트는 네트워크를 통해 메타데이터 서버 및 파일의 일부(청크)를 포함하는 여러 데이터 서버에 연결
- 메타데이터 서버는 어떤 데이터 서버가 어떤 파일의 청크를 보유하는지에 대한 매핑을 유지
    
    또한 디텍터리 및 파일의 전통적인 계층적 매핑을 유지
    
- 메타데이터는 데이터 서버 간의 파일 일부(청크)를 재분배하고 균형을 맞춤

> 파일 엑세스 방법
> 
- 클라이언트는 메타데이터 서버에 접속해야 함
- 베타데이터 서버는 요청된 파일 일부(청크)를 가진 데이터 서버 ID를 클라이언트에게 반환
- 클라이언트는 가장 가까운 데이터 서버에 접속하여 파일 정보를 수신
    - 파일이 서로 다른 데이터 서버에 저장된 경우 병렬로 읽거나 쓸 수 있음

> GFS
> 
- Google은 MapReduce 라는 SW를 통해 **대규모 병렬 처리를** 더 쉽게 수행할 수 있게 함

![Untitled](%5B%E1%84%80%E1%85%A9%E1%86%BC%E1%84%85%E1%85%AD%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%5D%20ch19%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%2037b82fc0c0ac48e08a9e2afe4cde6f93/Untitled%209.png)

# ❏ 19.7 DFS 명명 및 투명성

<aside>
💡 1. 명명 구조
2. 명명 기법
3. 구현 기법

</aside>

> 명명
> 
- 명명(naming)은 논리적 객체와 물리적 객체 사이의 매핑임
    
    ex. 사용자는 파일 이름으로 표시되는 논리적 데이터 객체를 처리하는 반면,
    
          시스템은 디스크 트랙에 저장된 물리적 데이터 블록을 조작함.
    
    전자는 텍스트 이름으로 파일을 참조, 후자는 하위 수준의 숫자 식별자에 매핑되며 이 식별자는 다시 디스크 블록에 매핑
    
- 후자와 같은 다중 수준 매핑은 파일의 추상화를 사용자에게 제공함
    
    파일의 추상화란, 파일이 디스크에 저장되는 방법과 위치에 대한 세부 사항을 숨기는 것
    

> 투명한 DFS
> 
- 추상화에 새로운 차원이 추가됨
    
    즉, 네트워크 내에서 파일의 위치를 숨김
    
    - 기존의 파일 시스템에서 명명 매핑의 범위는 디스크 내의 주소
        
        하지만, DFS 에서는 파일이 저장된 디스크가 연결된 특정 기기를 포함하도록 확장 됨
        
- 파일을 추상화 개념으로 다룬다는 개념은 **파일 복제 가능성**을 염
    
    파일 이름이 지정되면, 매핑은 이 파일의 복제본들 위치 집합을 반환
    
    (추상화에서 여러 사본의 존재와 해당 위치는 숨겨짐)
    

## ✏️ 명명 구조

- 이름 매핑과 관련하여 두 가지 개념이 있음
    - 위치 투명성
        - 파일 이름은 파일의 물리적 저장 위치에 대한 어떤 힌트도 드러내지 않음
    - 위치 독립
        - 파일의 물리적 저장위치가 변경될 때 파일 이름은 변경될 필요가 없음
    - 위치 독립적인 명명 체계는 동일한 파일 이름을 다른 시점에 다른 위치로 매핑할 수 있기 때문에 동적 매핑이며, 위치 투명성보다 더 강력한 속성임

## ✏️ 명명 기법

- 명명 기법에 대한 세가지 주요 접근 방식이 있음

> 호스트 이름과 로컬 이름의 조합으로 파일 식별
> 
- ex. host:local-name
- 위치 투명성과 위치 독립성이 보장되지 않음

> 일관성 있는 트리 모양을 통한 명명 (NFS를 이용하여 원격 디렉터리를 로컬 디렉터리에 연결하며 명명)
> 
- 자동 마운트 기능의 출현으로 마운트 포인트 테이블과 파일 구조 이름을 기반으로 필요에 따라 마운트 수행
- 서로 다른 원격 디렉터리를 트리에 연결할 수 있음 → 구조가 다양함

> 단일 전역 이름 구조를 시스템의 모든 파일에 적용
> 
- OpenAFS 는 내보내는 파일과 디렉터리에 대해 단일 글로벌 네임 스페이스를 제공하기 때문에 클라이언트 기기가 다르더라도 사용자에게 유사한 경험 제공

> 명명 구조 평가
> 
- 관리의 복잡성을 통해 명명 구조를 평가
- 가장 어려운 구조는 NFS 구조
    - 어떤 원격 디렉터리이든 로컬 디렉터리 트리의 어느 곳에 연결될 수 있기 때문임 (비조직적)

## ✏️ 구현 기법

- 투명한 명명을 구현하려면 파일 이름을 관련 위치에 매핑하기 위한 대비가 필요
    - 매핑 관리를 하기 위해 파일 집합을 구성 요소 단위로 묶고, 파일 하나 단위가 아닌 구성요소 단위로 매핑해야함
- 매핑 정보의 가용성을 높이기 위해 복제, 로컬 캐싱 또는 둘 다 사용할 수 있음

- 낮은 수준의 위치 독립적 파일 식별자를 도입
    - 텍스트 파일 이름은 파일이 속한 구성요소 단위를 나타내는 하위 수준 파일 식별자로 매핑
    - 두 번째 수준의 매핑이 필요함.

- 낮은 수준 식별자를 구현하는 일반적인 방법은 구조화된 이름을 사용하는 것
    - 두 부분으로 구성된 비트 문자열
        - 첫 번째 부분은 파일이 속하는 구성요소 단위를 식별
        - 장치 내의 특정 파일을 식별

# ❏ 19.8 원격 파일 엑세스

<aside>
💡 1. 원격 엑세스 기법

</aside>

- 파일을 저장하는 서버는 명명 기법에 의해 위치하고,
    
    원격 파일에 대한 엑세스를 요청하는 사용자 고려하여 실제 데이터 전송이 수행되어야 함
    

## ✏️원격 엑세스 기법

- 엑세스 요청을 서버로 전달하고, 서버 기기가 엑세스를 수행한 후 결과를 사용자에게 다시 전달

### ☝🏻 기본 캐싱 기법

- 엑세스 요청을 충족시키는데 필요한 데이터가 아직 캐시되지 않은 경우,
    
    클라이언트 시스템은 서버에서 데이터 사본을 가져옴
    
    → 캐시 된 사본에서 엑세스 수행
    
    - 최근 액세스 한 디스크 블록을 캐시에 유지하여 동일한 정보에 대해 반복적인 엑세스를 추가 네트워크 트래픽 없이 로컬에서 처리할 수 있도록 함
- 캐시 사본이 수정되면 변경 사항을 마스터 사본에 반영해야 함
    - 캐시 일관성 문제

### ☝🏻 캐시 위치

- 캐시된 데이터를 어디에 저장해야 하는가?
    - 디스크 (비휘발성 메모리)
        - 신뢰할 수 있음
    - 메인메모리 (휘발성 메모리)
        - 엑세스가 빠름
        - 기술은 메모리의 성능을 꾸준히 향상 시킴 → 디스크 캐시의 장점을 능가할 것임
        - 서버 캐시는 메인 메모리에 저장됨. 클라이언트에서도 메인 메모리에 캐시를 사용하면, 서버와 사용자 모두 사용할 수 있는 단일 캐싱 기법 구축 가능

### ☝🏻 캐시 업데이트 정책

- 수정된 데이터 블록을 서버의 마스터 사본에 다시 쓰는데 사용되는 정책은 시스템의 성능과 신뢰성에 중대한 영향을 미침

> Write-through 정책
> 
- 데이터를 캐시에 저장하자마자, 디스크에 쓰는 것
- 장점
    - 높은 신뢰성
- 단점
    - 데이터가 서버로 전송될 때까지 모든 쓰기 엑세스가 기다리므로 쓰기 성능 저하

> Delayed-write policy (지연-쓰기 정책)
> 
- write-back 캐싱, 마스터 복사본에 대한 업데이트를 지연시킴
    - 수정 사항은 캐시에 기록된 후, 나중에 서버에 기록
- Write_through 보다 좋은 점
    - 캐시에 쓰기 작업이 수행되므로, 쓰기 엑세스 성능 좋음
    - 데이터를 덮어쓸 수 있기 때문에, 마지막 업데이트만 기록하면 됨
- 단점
    - 신뢰성이 낮음
        - 사용자 시스템이 크래시 될 때마다 기록되지 않은 데이터가 손실되기 때문임

> Write-on-close 정책
> 
- 파일이 닫힐 때 서버에 데이터를 다시 쓰는 것
- 오랫동안 열려 있고 자주 수정되는 파일의 경우에 이점이 있음

### ☝🏻 일관성

- 클라이언트 시스템은 로컬로 캐시된 데이터 사본이 마스터 사본과 일치하는지 결정하는 문제에 직면함
    
    즉, 캐시된 데이터의 유효성을 검증해야 함
    

> 클라이언트 주도 방식
> 
- 클라이언트는 서버에 접속해서 로컬 데이터가 마스터 사본과 일치하는지 확인하며 유효성 검사 시작
- 빈도에 따라 유효성 검사는 네트워크와 서버의 부하를 높임

> 서버 주도 방식
> 
- 서버는 각 클라이언트가 캐시하는 파일을 기록함
- 상충하는 모드의 두 클라이언트가 파일을 캐시할 때 불일치가 발생할 수 있음
    - 서버는 파일이 열릴 때마다 모드가 표시되어야 하며, 파일이 상충하는 모드로 동시에 열린 것을 감지했을 때 그 파일에 대한 캐싱을 비활성화시켜 조처함

# ❏ 19.10 요약

- 분산 시스템은 메모리나 시계를 공유하지 않는 프로세서 모음.
    
    각 프로세서는 자체 로컬 메모리를 가지고, 버스&인터넷 같은 다양한 통신 회선을 통해 서로 통신함.
    
- 분산 시스템은 사용자에게 모든 시스템 자원에 대한 엑세스 제공
    
    공유 자원에 대한 접근은 데이터, 계산, 프로세스 마이그레이션을 통해 제공
    
- 프로토콜 스택은 네트워크 계층화 모델에 의해 지정된 대로 메시지에 정보를 추가하여 메시지가 목적지에 도착하는 것을 보장
- 호스트 이름을 네트워크 주소로 변환하려면 명명 시스템(ex. DVS)를 사용해야함
    
    네트워크 번호를 네트워크 장치 주소로 변환하려면 다른 프로토콜(ARP 등) 이 필요함
    
- 시스템이 별도의 네트워크에 있는 경우 패킷 전달을 위해 라우터가 필요함
- UDP & TCP는 고유한 시스템 전체 포트 번호를 사용하여 패킷을 대기 중인 프로세스에 보냄
    
    TCP 프로토콜은 패킷의 흐름이 신뢰할 수 있는 연결 지향 바이트 스트림이 되도록 함
    
- 분산 시스템의 올바른 작동을 위해 극복해야할 문제가 있음
    - 문제
        1. 시스템 노드 및 프로세스 명명
        2. 결함 허용
        3. 오류 복구 및 확장성
            1. 증가한 부하 처리
            2. 결함 허용성 유지
            3. 압축, 중복 제거 가능성을 포함한 효율적인 저장장치 기법 사용
- DFS 는 클라이언트, 서버 및 저장장치가 분산 시스템의 사이트에 분산된 파일 서비스 시스템임
    
    서비스 활동은 네트워크를 통해 수행되어야하고, 하나의 중앙 집중식 데이터 저장소 대신 여러 개의 독립적인 저장장치가 있음
    
- 서버와 저장장치의 다양성 & 분산은 투명해야 함
    
    투명한 DFS는 클라이언트 환경을 클라이언트가 로그인한 시스템으로 가져와서 클라이언트 이동성을 용이하게 함
    
- DFS에는 명명 기버에 대한 몇 가지 접근 방식이 있음
    1. 파일 이름을 호스트 이름과 로컬 이름으로 조합
    2. 원격 디렉터리를 로컬 디렉터리에 연결할 수 있는 수단을 제공하여 일관성 있는 디렉터리 트리 모양 제공(NFS 에 의해 대중화 됨)
- 원격 파일에 액세스 하기 위한 요청에는 두 가지 방법이 있음
    - 원격 서비스를 사용하면 액세스 요청이 서버로 전달. 서버 기기는 액세스를 수행하고, 그 결과를 클라이언트에 다시 전달
    - 캐싱을 사용하여 액세스 요청을 충족시키는 데 필요한 데이터가 아직 캐시되지 않은 경우 서버에서 클라이언트로 데이터 사본을 가져옴
        
        캐시된 사본에서 액세스 수행 → 캐시 일관성 문제 ( 캐시된 사본을 마스터 파일과 일관되게 유지하는 문제)
